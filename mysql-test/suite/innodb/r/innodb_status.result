#
# Test that the INNODB_LOCK_DEADLOCKS is incremented when a deadlock
# is detected.
#

# Save initial value of the INNODB_LOCK_DEADLOCKS variable.

SELECT VARIABLE_VALUE INTO @deadlocks_1 FROM INFORMATION_SCHEMA.GLOBAL_STATUS
WHERE VARIABLE_NAME = 'INNODB_LOCK_DEADLOCKS';

# Simulate a deadlock scenario.

CREATE TABLE t1 (a INT PRIMARY KEY, b INT NOT NULL) ENGINE=InnoDB;
INSERT INTO t1 VALUES (1,2);
# Connection: con1
BEGIN;
# Take a shared lock on the existing record (1,2).
SET DEBUG_SYNC='write_row_noreplace SIGNAL insert1 WAIT_FOR select1';
INSERT INTO t1 VALUES (1,3);
# Connection: default
SET DEBUG_SYNC='now WAIT_FOR insert1';
SELECT * FROM t1 LOCK IN SHARE MODE;
a	b
1	2
# Attempt to get an exclusive lock for the same record.
SELECT * FROM t1 FOR UPDATE;
# Connection: con2
# Wait for lock attempt to be blocked.
SET DEBUG_SYNC='now SIGNAL select1';
# Connection: con1
ERROR 23000: Duplicate entry '1' for key 'PRIMARY'
# Attempt to get an exclusive lock for the same record.
INSERT INTO t1 VALUES (1,3) ON DUPLICATE KEY UPDATE b = b + 10;
# Connection: default
ERROR 40001: Deadlock found when trying to get lock; try restarting transaction
# Connection: con1
COMMIT;
# Connection: default

# Check if INNODB_LOCK_DEADLOCKS was incremented.

SELECT VARIABLE_VALUE INTO @deadlocks_2 FROM INFORMATION_SCHEMA.GLOBAL_STATUS
WHERE VARIABLE_NAME = 'INNODB_LOCK_DEADLOCKS';
SELECT @deadlocks_1 < @deadlocks_2;
@deadlocks_1 < @deadlocks_2
1
DROP TABLE t1;
